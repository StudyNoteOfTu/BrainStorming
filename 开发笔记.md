## 优化重复体力工作 - 注解场景 - 代码生成

- 通过配置文件，把重复注册的信息放到配置文件，后续需要维护配置文件，与代码进行解耦。
- 通过注解处理器APT，在编译时进行文件处理，包括生成文件、修改文件等。将重复体力工作变为一种标注，通过自动化方式，扫描所有文件，寻找到标注，进行处理。【文件扫描+解析处理】

> 注解结合的场景：
>
> 反射（Runtime运行时注解）、APT-annotation processor tool（Source编译时注解）、字节码插桩（Class字节码时注解）

【代码生成】根据规则，生成符合要求的代码/字节码，加载到系统进行使用。结合APT注解处理器，辅助生成代码，使得框架有更多的支持。Android中，可以通过AS的gradle配置，来发起apt：

```java
//annotationProcessor在Android Gradle 2.2之后由Google引入的，是Gradle中内置的APT工具，同时支持 javac 和 jack 编译方式。使用方式（即Java语言下的使用方式）如下：
dependencies {
    annotationProcessor "com.alibaba:arouter-compiler:1.2.2"
}
```

> APT - Javac
>
> https://blog.csdn.net/zzz777qqq/article/details/127624497
>
> apt  - gradle
>
> https://blog.csdn.net/l460133921/article/details/104908122

注意生成.java类和.class类的区别：

- APT - 生成.java类（编译前）

- 字节码插桩 - 生成.class类

## 模块化结构 - 依赖关系

- 同一层的不同模块之间不相互依赖
- 业务层和工具层相分离，业务层在上，工具层在下，业务层依赖工具层，下层禁止被上层依赖

## 去中心化 - 注册下沉

- 信息中心/注册中心，例如将组件/模块的注册放到了Application中执行，换而言之，在最上层（APP壳）对业务层的各个模块进行注册。APP壳成了信息中心/注册中心。

- 去中心化：信息/注册的执行进行下沉。（不再是将军对小兵进行点名，变为小兵主动上报）

- 去中心化好处：将修改、拓展交给了子节点。而不是每次有新的子节点（小兵）时，主节点（将军）都要对代码进行更新。

- 去中心化方式：制定标准（例如抽象父类、接口）

- 实现方式1：

  每个业务层模块都写一个本模块的注册类，将注册信息写入方法/函数。主模块只负责对业务层的注册类进行引入，而具体的注册信息，由子模块自己来写。（类似接口回调，将注册的接口暴露，把注册逻辑的实现交给子模块）

  ```java
  主模块{
      Map registerMap;
      func init(){
          子模块1.注册类.register(registerMap);
          子模块2.注册类.register(registerMap);
          //...
      }
  }
  
  接口{
      func register(Map map);
  }
  
  子模块1.注册类{
      override register(Map map){
          map.put(a,a);
          map.put(b,b);
      }
  }
  
  子模块1.注册类{
      override register(Map map){
          map.put(a,a);
          map.put(b,b);
      }
  }
  ```

  而主模块要获取到子模块的注册类，又是一个挑战。反射的方式需要思考。参考热修复思路，替换apk中原有类的方法，优先调用到补丁包里面的类/方法（这样就可以避免写代码时/编译时出现找不到类的问题，写代码时找的是临时类，而运行时则执行的是实际目标类）。

  注意，最终多模块都会打包到一个apk中。

  ```
  1. 获取当前应用的apk文件（dex） - PMS - ApplicationInfo.sourceDir
  apk路径：data/app/...
  2. 通过dexFile遍历dex中的所有类
  	也可以是jar包、zip包、apk包等，只要有dex文件即可
  3. 筛选符合规则的类，例如按照约定：
  	在 com.test.demo包下且实现了某接口的类
  4. 反射实例化，完成子模块的类的函数的调用。
  ```

- 实现方式2：

  避免手动创建/维护注册类，通过APT注解处理器的方式，将手动维护变为自动维护。

  【代码生成】

## 热修复 - dex

- Android类加载器
- 双亲委派机制
- 类查找流程

例如，阿里的热修复，会给一个补丁包：dex文件。优先从dex中进行类查找，替换掉apk中原有的类。

> 获取dex文件中所有类的方式：
>
> DexFile.java 
>
> - DexFile.loadDex将dex文件加载到系统中
> - DexFile.entries()可以拿到所有类的全限定名



## 鲁棒性（健壮性）

框架开发者，需要健壮性，考虑用户不符合流程要求的奇怪的用例。





